<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从实现一个简单的排序器学习策略模式</title>
      <link href="/2020/07/18/cong-shi-xian-yi-ge-jian-dan-de-pai-xu-qi-xue-xi-ce-lue-mo-shi/"/>
      <url>/2020/07/18/cong-shi-xian-yi-ge-jian-dan-de-pai-xu-qi-xue-xi-ce-lue-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="从实现一个简单的排序器学习策略模式"><a href="#从实现一个简单的排序器学习策略模式" class="headerlink" title="从实现一个简单的排序器学习策略模式"></a>从实现一个简单的排序器学习策略模式</h2><p>策略模式是对算法的封装，把一系列的算法分别封装到对应的类中，并且这些类实现相同的接口，相互之间可以替换。当对象有某个行为，但是在不同的场景中该行为有不同的实现算法，这时便可以使用策略模式这一设计模式。</p><h3 id="1、问题引入"><a href="#1、问题引入" class="headerlink" title="1、问题引入"></a>1、问题引入</h3><p>假设我们有一个排序器，使用简单的插入排序实现对int类型的数组进行排序，代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rul<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>strategy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 简单插入排序排序器 * * @author LuoRu */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Sorter01</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> temp <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//元素向后移动</span>                array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//插入元素</span>            array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        Sorter01 sorter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sorter01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sorter<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如果某一天我们想要对double类型数组排序怎么办、想对自定义类型数组排序怎么办？直接往排序器里面加sort方法，实现很多的重载方法？这样每当我们想要对一种新类型进行排序，就需要新写一个重载方法，最终会使代码变得特别臃肿。我们可以这样实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rul<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>strategy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 规定每个需要使用Sorter02进行排序的类必须实现Comparable接口 * * @param &lt;T>实现类的类型 * @author LuoRu */</span><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>T o<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>我们设计一个Comparable接口，包含一个compareTo方法，该方法用来实现两个对象比较大小的策略。同时我们规定想要使用排序器进行排序的类型必须实现该接口。如下，我们定义了Cat类型，并实现了Comparable接口，实现的compareTo方法表示age小的Cat小。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rul<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>strategy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 自定义类型，我们想要通过排序器对该类型的数组进行排序 * * @author LuoRu */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Cat<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">int</span> weight<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token keyword">int</span> weight<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>Cat o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">-</span> o<span class="token punctuation">.</span>age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Cat{"</span> <span class="token operator">+</span>                <span class="token string">"age="</span> <span class="token operator">+</span> age <span class="token operator">+</span>                <span class="token string">", weight="</span> <span class="token operator">+</span> weight <span class="token operator">+</span>                <span class="token string">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后我们便可以将排序器的代码改成下面这样，就可以对所有实现了Comparable接口的类型的数组进行排序了。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rul<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>strategy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 对实现了Comparable接口的对象进行排序 * * @author LuoRu */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Sorter02</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparable<span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Comparable temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> temp<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//元素向后移动</span>                array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//插入元素</span>            array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Cat<span class="token punctuation">[</span><span class="token punctuation">]</span> cats <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        Sorter02 sorter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sorter02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sorter<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>cats<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>cats<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>但是有一天，我们又突然想对Cat类型的数组按照weight而不是age进行排序了，怎么办？最容易想到的办法就是修改Cat中的compareTo方法的实现，但是这样违反了软件设计中的”开闭原则–对拓展开放，对修改关闭“，而且这样不能使两种排序策略在程序中同时存在，也就是说不能在同一程序中某处按照age排序，而在另外一处则使用weight排序。</p><h3 id="2、策略模式登场"><a href="#2、策略模式登场" class="headerlink" title="2、策略模式登场"></a>2、策略模式登场</h3><p>我们可以通过策略模式很简单地实现前面的需求。首先定义一个泛型接口，compare规定两个对象比较大小的策略。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rul<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>strategy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 比较策略接口 * * @param &lt;T>对需要进行比较对象的类型 * @author LuoRu */</span><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>T t1<span class="token punctuation">,</span> T t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>我们将Comparator实现类作为参数传入sort方法，这样每当我们想要按照新的排序规则进行排序的时候，只需要新创建一个Comparator接口的实现类就可以了。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rul<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>strategy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 将Comparator接口作为排序器的sort方法的参数 * * @param &lt;T>需排序的对象数组的类型 * @author LuoRu */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Sorter03</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> Comparator<span class="token operator">&lt;</span>T<span class="token operator">></span> comparator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            T temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//元素向后移动</span>                array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//插入元素</span>            array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Cat<span class="token punctuation">[</span><span class="token punctuation">]</span> cats <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        Sorter03<span class="token operator">&lt;</span>Cat<span class="token operator">></span> sorter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sorter03</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sorter<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>cats<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> t2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> t1<span class="token punctuation">.</span>age <span class="token operator">-</span> t2<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"按照age从小到大排序:"</span> <span class="token operator">+</span> Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>cats<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sorter<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>cats<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> t2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> t2<span class="token punctuation">.</span>weight <span class="token operator">-</span> t1<span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"按照weight从大到小排序:"</span> <span class="token operator">+</span> Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>cats<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="3、策略模式的结构"><a href="#3、策略模式的结构" class="headerlink" title="3、策略模式的结构"></a>3、策略模式的结构</h3><h4 id="①Context上下文："><a href="#①Context上下文：" class="headerlink" title="①Context上下文："></a>①Context上下文：</h4><p>Context上下文角色，也叫Context封装角色，起承上启下的作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。对应上面实例中的Sorter03。</p><h4 id="②抽象策略角色："><a href="#②抽象策略角色：" class="headerlink" title="②抽象策略角色："></a>②抽象策略角色：</h4><p>抽象策略角色，是对策略、算法的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性。对应上面实例中的Comparator接口。</p><h4 id="③具体策略角色："><a href="#③具体策略角色：" class="headerlink" title="③具体策略角色："></a>③具体策略角色：</h4><p>具体策略角色通常由一组封装了算法的类来担任，这些类之间可以根据需要自由替换。对应上面实例中的Sorter03中main方法中的Lambda表达式。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单例模式的七种写法及简单分析</title>
      <link href="/2020/07/17/dan-li-mo-shi-de-qi-chong-xie-fa-ji-jian-dan-fen-xi/"/>
      <url>/2020/07/17/dan-li-mo-shi-de-qi-chong-xie-fa-ji-jian-dan-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式的七种写法及简单分析"><a href="#单例模式的七种写法及简单分析" class="headerlink" title="单例模式的七种写法及简单分析"></a>单例模式的七种写法及简单分析</h2><p>单例模式是最简单的设计模式之一，属于创建型模式，它提供了一种创建对象的方式，确保只有单个对象被创建。这个设计模式主要目的是想在整个系统中只能出现类的一个实例，即一个类只有一个对象。单例模式主要是为了解决创建对象时较耗资源耗时间的问题。</p><h3 id="1、饿汉式写法"><a href="#1、饿汉式写法" class="headerlink" title="1、饿汉式写法"></a>1、饿汉式写法</h3><p>这种写法主要的问题是静态变量在类加载进内存时就会初始化，即使没有使用，并且不能防止用户通过反序列化的方式实例化对象。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rul<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>singleton<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 饿汉式 * 优点：写法简单 * 缺点：即使不使用也会实例化一个对象，不能防止反序列化 * * @author LuoRu */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager01</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Manager01 INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//构造方法私有化</span>    <span class="token keyword">private</span> <span class="token function">Manager01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Manager01 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//成员方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="2、饿汉式静态初始化块写法"><a href="#2、饿汉式静态初始化块写法" class="headerlink" title="2、饿汉式静态初始化块写法"></a>2、饿汉式静态初始化块写法</h3><p>本质与上一种写法一样，只是实例化时放入静态初始化块中。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rul<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>singleton<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 饿汉式静态初始化块写法 * 优点：写法简单，与Manager01写法本质一样 * 缺点：即使不使用也会实例化一个对象，不能防止反序列化 * * @author LuoRu */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager02</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Manager02 INSTANCE<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//构造方法私有化</span>    <span class="token keyword">private</span> <span class="token function">Manager02</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Manager02 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//成员方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="3、懒汉式写法"><a href="#3、懒汉式写法" class="headerlink" title="3、懒汉式写法"></a>3、懒汉式写法</h3><p>这种写法只有在使用了的情况下才实例化对象，但是这种写法可能会导致在多线程环境下多个线程得到的实例不是同一个的问题，因为getInstance方法可能会被其他线程打断，同时也不能防止反序列化。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rul<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>singleton<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 懒汉式 * 优点：写法简单，只有使用到才会实例化一个对象 * 缺点：多线程环境下不能保证单例，不能防止反序列化 * * @author LuoRu */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager03</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Manager03 INSTANCE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//构造方法私有化</span>    <span class="token keyword">private</span> <span class="token function">Manager03</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Manager03 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>INSTANCE <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager03</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//成员方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="4、懒汉式加锁写法"><a href="#4、懒汉式加锁写法" class="headerlink" title="4、懒汉式加锁写法"></a>4、懒汉式加锁写法</h3><p>这种写法解决了上一种写法在多线程环境中存在的问题，但是加锁导致了更多的性能开销，同样不能防止反序列化。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rul<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>singleton<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 懒汉式加锁 * 优点：写法简单，只有使用到才会实例化一个对象,多线程环境下能保证单例 * 缺点：加锁影响效率，不能防止反序列化 * * @author LuoRu */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager04</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Manager04 INSTANCE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//构造方法私有化</span>    <span class="token keyword">private</span> <span class="token function">Manager04</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//加锁，防止多线程环境下不止实例化一个对象问题</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Manager04 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>INSTANCE <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager04</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//成员方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="5、懒汉式双重判断加锁写法"><a href="#5、懒汉式双重判断加锁写法" class="headerlink" title="5、懒汉式双重判断加锁写法"></a>5、懒汉式双重判断加锁写法</h3><p>这种写法解决了上一种写法性能过多开销问题，但写法稍复杂，并且同样不能防止反序列化。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rul<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>singleton<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 懒汉式双重判断加锁 * 优点：只有使用到才会实例化一个对象,多线程环境下能保证单例 * 缺点：写法稍复杂，不能防止反序列化 * * @author LuoRu */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager05</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//volatile防止指令重排序</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> Manager05 INSTANCE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//构造方法私有化</span>    <span class="token keyword">private</span> <span class="token function">Manager05</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//双重判断加锁</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Manager05 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//外层判断保证只有未实例化时才加锁</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>INSTANCE <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Manager05<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//内层判断防止多线程环境下不止实例化一个对象</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>INSTANCE <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager05</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//成员方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="6、懒汉式静态内部类写法"><a href="#6、懒汉式静态内部类写法" class="headerlink" title="6、懒汉式静态内部类写法"></a>6、懒汉式静态内部类写法</h3><p>这种写法较为理想，因为外部类在加载时并不会加载静态内部类，所以实现了懒加载，但同样不能防止反序列化。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rul<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>singleton<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 懒汉式静态内部类 * 优点：写法简单，只有使用到才会实例化一个对象,多线程环境下能保证单例 * 缺点：不能防止反序列化 * * @author LuoRu */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager06</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//使用静态内部类保证只有使用到才实例化一个对象</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ManagerHolder</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> Manager06 INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager06</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//构造方法私有化</span>    <span class="token keyword">private</span> <span class="token function">Manager06</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Manager06 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ManagerHolder<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//成员方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="7、枚举单例写法"><a href="#7、枚举单例写法" class="headerlink" title="7、枚举单例写法"></a>7、枚举单例写法</h3><p>《Effective Java》作者（同时也是Java开发人员之一）提供的一种写法，通过枚举类解决了反序列化问题，因为枚举类是不提供构造方法的，所以用户并不能通过反射机制反序列化实例。但枚举类的写法给人的感觉不是很友好，不容易理解。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rul<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>singleton<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 枚举单例 * 优点：多线程下能保证单例，能防止反序列化 * 缺点：不容易理解 * * @author LuoRu */</span><span class="token keyword">public</span> <span class="token keyword">enum</span> Manager07 <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//使用Manager07.INSTANCE.method()调用成员方法</span>    INSTANCE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//成员方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汉诺塔</title>
      <link href="/2020/07/17/han-nuo-ta/"/>
      <url>/2020/07/17/han-nuo-ta/</url>
      
        <content type="html"><![CDATA[<h2 id="THE-TOWER-OF-HANOI"><a href="#THE-TOWER-OF-HANOI" class="headerlink" title="THE TOWER OF HANOI"></a>THE TOWER OF HANOI</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>汉诺塔（也称河内塔）是有法国数学家爱德华·卢卡斯于1883年发明的一道智力题。它源于印度的一个古老传说：大梵天创造世界的时候做了三根钻石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令一组牧师把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。据说牧师们夜以继日地工作，当他们完成任务时，那座塔就将坍塌，世界也将毁灭。</p><p>汉诺塔问题是这样规定的：如下图，一个由8个圆盘组成的塔，这些圆盘从下向上按照大小递减的方式套在一根柱子上，我们的目的是要将这根柱子上的所有圆盘移动到另一根柱子上，每次只能移动一个圆盘，且在移动过程中较大的圆盘不能放置在较小的圆盘上面。</p><img src="image-20200714121332706.png" alt="image-20200714121332706" style="zoom:80%;" /><p>已经证明这个智力题有解，现在问题来了：我们能做到的最好的解法是什么？也就是说，要完成这项任务至少移动多少次才是必须且足够的？</p><p>解决这样的问题的最好方法是对它稍加推广，印度传说中的塔有64个圆盘，汉诺塔问题中的塔有8个圆盘，我们将这个问题推广为有n个圆盘，这样我们简化一下这个问题。如下图，n个圆盘套在A柱上，按照与汉诺塔相同的规则移动到C柱上，至少需要移动多少次。</p><img src="image-20200714122326196.png" alt="image-20200714122326196" style="zoom:80%;" /><h3 id="数学分析"><a href="#数学分析" class="headerlink" title="数学分析"></a>数学分析</h3><p>我们假设T<sub>n</sub> 是根据规则将n个圆盘从一根柱子移动到另一根柱子所需要的最少移动次数。那么T<sub>0</sub>显然是0，T<sub>1</sub> = 1，T<sub>2</sub> = 3。</p><p>现在我们改变一下视角，来考虑大的情形：怎样才能移动一个大的塔呢？将n个圆盘从A柱移动到C柱可以分三步来完成，首先将A柱上面的n-1个圆盘从A柱移动到B柱上，这一步需要移动T<sub>n-1</sub>次。然后将A柱上剩下的那个最大的盘移动到C柱上，这一步需要移动1次。最后将B柱上的n-1个盘移动到C柱上，这一步也需要移动T<sub>n-1</sub>次。所以n(n&gt;0)个圆盘移动2T<sub>n-1</sub>+1次是足够了的，但是我们并没有证明2T<sub>n-1</sub>+1是最少的移动次数，因此：<br>$$<br>T_n \leq 2T_{n-1} + 1, n &gt; 0<br>$$<br>那么还有更好的办法吗？实际上没有，因为我们迟早必须移动最大的那个圆盘。当我们这样做的时候，那n-1个圆盘必须已经在另外某根柱子上，而这一步至少需要移动T<sub>n-1</sub>次，这样我们才能把最大的那个盘移动到第三根柱子上（大盘不能放在小盘上面），移动完最大的盘之后，我们必须把n-1个小的圆盘（此时它们全部处于同一根柱子上）移到最大的盘的上面，这也至少需要移动T<sub>n-1</sub>次，因此：<br>$$<br>T_n \geq 2T_{n-1} + 1,n &gt; 0<br>$$<br>把这两个不等式与n=0时的平凡解结合在一起就得到：<br>$$<br>\begin{cases} T_n = 0,n = 0\ \ T_n = 2T_{n-1} + 1,n &gt; 0 \end{cases}<br>$$<br>得到这样一个递归式之后，我们就可以通过T<sub>0</sub>求出T<sub>1</sub>、由T<sub>1</sub>求出T<sub>2</sub>、由T<sub>2</sub>求出T<sub>3</sub>…最终求出任意的T<sub>n</sub>，这交给计算机程序是很容易计算出T<sub>n</sub>的。但是，如果没有计算机让你去计算T<sub>64</sub>，相信并没人会愿意从T<sub>1</sub>一步一步计算到T<sub>64</sub>。那么有没有一个既漂亮又简介的式子供我们快捷计算T<sub>n</sub>呢，即使n很大？</p><p>我们先在递归式方程的两边加上1：<br>$$<br>\begin{cases} T_n + 1 = 1,n = 0\ \ T_n + 1 = 2T_{n-1} + 2,n &gt; 0 \end{cases}<br>$$<br>现在假设U<sub>n</sub> = T<sub>n</sub> + 1，那么就有：<br>$$<br>\begin{cases} U_n = 1,n = 0\ \ U_n = 2U_{n-1},n &gt; 0 \end{cases}<br>$$<br>显而易见，这个递归方程的解为U<sub>n</sub> = 2<sup>n</sup>（你可以通过数学归纳法证明），从而T<sub>n</sub> = 2<sup>n</sup> - 1。</p><h3 id="代码求解"><a href="#代码求解" class="headerlink" title="代码求解"></a>代码求解</h3><p>下面给出根据上述分析求解结果的Java代码，因计算结果太大，计算过程中均使用BigInteger代替基本数据类型进行运算。</p><p><code>代码</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rul<span class="token punctuation">.</span>mathematics<span class="token punctuation">.</span>hanoi<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>math<span class="token punctuation">.</span>BigInteger<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * THE TOWER OF HANOI * * @author LuoRu */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Hanoi</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"递归求解：T8 = "</span> <span class="token operator">+</span> <span class="token function">getAnswerByRecursive</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span>                <span class="token string">"  T64 = "</span> <span class="token operator">+</span> <span class="token function">getAnswerByRecursive</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"迭代求解：T8 = "</span> <span class="token operator">+</span> <span class="token function">getAnswerByIterate</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span>                <span class="token string">"  T64 = "</span> <span class="token operator">+</span> <span class="token function">getAnswerByIterate</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"公式求解：T8 = "</span> <span class="token operator">+</span> <span class="token function">getAnswerByFormula</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span>                <span class="token string">"  T64 = "</span> <span class="token operator">+</span> <span class="token function">getAnswerByFormula</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 递归方式求解     *     * @param n 汉诺塔圆盘数量     * @return 移动n个盘最少需要移动的次数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> BigInteger <span class="token function">getAnswerByRecursive</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">getAnswerByRecursive</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">multiply</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 迭代方式求解     *     * @param n 汉诺塔圆盘数量     * @return 移动n个盘最少需要移动的次数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> BigInteger <span class="token function">getAnswerByIterate</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        BigInteger answer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            answer <span class="token operator">=</span> answer<span class="token punctuation">.</span><span class="token function">multiply</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> answer<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 一般求解     *     * @param n 汉诺塔圆盘数量     * @return 移动n个盘最少需要移动的次数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> BigInteger <span class="token function">getAnswerByFormula</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        BigInteger answer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> answer<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">subtract</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>结果</code></p><pre><code>递归求解：T8 = 255  T64 = 18446744073709551615迭代求解：T8 = 255  T64 = 18446744073709551615公式求解：T8 = 255  T64 = 18446744073709551615</code></pre><p>可以发现，我们上面得出的T<sub>n</sub> = 2<sup>n</sup> - 1与递归式的结果是一致的。</p><p>假设牧师们1秒钟移动圆盘1次，一天24小时不间断移动，一年算365天，在不犯错的情况下需要大概584942417355年才能将64个盘子移动完。所以牧师们的任务还没有完成，他们现在仍然在移动圆盘。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
