<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>单例模式的七种写法及简单分析</title>
      <link href="/2020/07/17/dan-li-mo-shi-de-qi-chong-xie-fa-ji-jian-dan-fen-xi/"/>
      <url>/2020/07/17/dan-li-mo-shi-de-qi-chong-xie-fa-ji-jian-dan-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式的七种写法及简单分析"><a href="#单例模式的七种写法及简单分析" class="headerlink" title="单例模式的七种写法及简单分析"></a>单例模式的七种写法及简单分析</h2><p>单例模式是最简单的设计模式之一，属于创建型模式，它提供了一种创建对象的方式，确保只有单个对象被创建。这个设计模式主要目的是想在整个系统中只能出现类的一个实例，即一个类只有一个对象。单例模式主要是为了解决创建对象时较耗资源耗时间的问题。</p><h3 id="1、饿汉式写法"><a href="#1、饿汉式写法" class="headerlink" title="1、饿汉式写法"></a>1、饿汉式写法</h3><p>这种写法主要的问题是静态变量在类加载进内存时就会初始化，即使没有使用，并且不能防止用户通过反序列化的方式实例化对象。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rul<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>singleton<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 饿汉式 * 优点：写法简单 * 缺点：即使不使用也会实例化一个对象，不能防止反序列化 * * @author LuoRu */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager01</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Manager01 INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//构造方法私有化</span>    <span class="token keyword">private</span> <span class="token function">Manager01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Manager01 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//成员方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="2、饿汉式静态初始化块写法"><a href="#2、饿汉式静态初始化块写法" class="headerlink" title="2、饿汉式静态初始化块写法"></a>2、饿汉式静态初始化块写法</h3><p>本质与上一种写法一样，只是实例化时放入静态初始化块中。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rul<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>singleton<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 饿汉式静态初始化块写法 * 优点：写法简单，与Manager01写法本质一样 * 缺点：即使不使用也会实例化一个对象，不能防止反序列化 * * @author LuoRu */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager02</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Manager02 INSTANCE<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//构造方法私有化</span>    <span class="token keyword">private</span> <span class="token function">Manager02</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Manager02 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//成员方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="3、懒汉式写法"><a href="#3、懒汉式写法" class="headerlink" title="3、懒汉式写法"></a>3、懒汉式写法</h3><p>这种写法只有在使用了的情况下才实例化对象，但是这种写法可能会导致在多线程环境下多个线程得到的实例不是同一个的问题，因为getInstance方法可能会被其他线程打断，同时也不能防止反序列化。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rul<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>singleton<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 懒汉式 * 优点：写法简单，只有使用到才会实例化一个对象 * 缺点：多线程环境下不能保证单例，不能防止反序列化 * * @author LuoRu */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager03</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Manager03 INSTANCE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//构造方法私有化</span>    <span class="token keyword">private</span> <span class="token function">Manager03</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Manager03 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>INSTANCE <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager03</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//成员方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="4、懒汉式加锁写法"><a href="#4、懒汉式加锁写法" class="headerlink" title="4、懒汉式加锁写法"></a>4、懒汉式加锁写法</h3><p>这种写法解决了上一种写法在多线程环境中存在的问题，但是加锁导致了更多的性能开销，同样不能防止反序列化。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rul<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>singleton<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 懒汉式加锁 * 优点：写法简单，只有使用到才会实例化一个对象,多线程环境下能保证单例 * 缺点：加锁影响效率，不能防止反序列化 * * @author LuoRu */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager04</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Manager04 INSTANCE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//构造方法私有化</span>    <span class="token keyword">private</span> <span class="token function">Manager04</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//加锁，防止多线程环境下不止实例化一个对象问题</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Manager04 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>INSTANCE <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager04</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//成员方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="5、懒汉式双重判断加锁写法"><a href="#5、懒汉式双重判断加锁写法" class="headerlink" title="5、懒汉式双重判断加锁写法"></a>5、懒汉式双重判断加锁写法</h3><p>这种写法解决了上一种写法性能过多开销问题，但写法稍复杂，并且同样不能防止反序列化。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rul<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>singleton<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 懒汉式双重判断加锁 * 优点：只有使用到才会实例化一个对象,多线程环境下能保证单例 * 缺点：写法稍复杂，不能防止反序列化 * * @author LuoRu */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager05</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//volatile防止指令重排序</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> Manager05 INSTANCE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//构造方法私有化</span>    <span class="token keyword">private</span> <span class="token function">Manager05</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//双重判断加锁</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Manager05 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//外层判断保证只有未实例化时才加锁</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>INSTANCE <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Manager05<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//内层判断防止多线程环境下不止实例化一个对象</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>INSTANCE <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager05</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//成员方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="6、懒汉式静态内部类写法"><a href="#6、懒汉式静态内部类写法" class="headerlink" title="6、懒汉式静态内部类写法"></a>6、懒汉式静态内部类写法</h3><p>这种写法较为理想，因为外部类在加载时并不会加载静态内部类，所以实现了懒加载，但同样不能防止反序列化。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rul<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>singleton<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 懒汉式静态内部类 * 优点：写法简单，只有使用到才会实例化一个对象,多线程环境下能保证单例 * 缺点：不能防止反序列化 * * @author LuoRu */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager06</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//使用静态内部类保证只有使用到才实例化一个对象</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ManagerHolder</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> Manager06 INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager06</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//构造方法私有化</span>    <span class="token keyword">private</span> <span class="token function">Manager06</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Manager06 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ManagerHolder<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//成员方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="7、枚举单例写法"><a href="#7、枚举单例写法" class="headerlink" title="7、枚举单例写法"></a>7、枚举单例写法</h3><p>《Effective Java》作者（同时也是Java开发人员之一）提供的一种写法，通过枚举类解决了反序列化问题，因为枚举类是不提供构造方法的，所以用户并不能通过反射机制反序列化实例。但枚举类的写法给人的感觉不是很友好，不容易理解。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rul<span class="token punctuation">.</span>designpattern<span class="token punctuation">.</span>singleton<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 枚举单例 * 优点：多线程下能保证单例，能防止反序列化 * 缺点：不容易理解 * * @author LuoRu */</span><span class="token keyword">public</span> <span class="token keyword">enum</span> Manager07 <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//使用Manager07.INSTANCE.method()调用成员方法</span>    INSTANCE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//成员方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汉诺塔</title>
      <link href="/2020/07/17/han-nuo-ta/"/>
      <url>/2020/07/17/han-nuo-ta/</url>
      
        <content type="html"><![CDATA[<h2 id="THE-TOWER-OF-HANOI"><a href="#THE-TOWER-OF-HANOI" class="headerlink" title="THE TOWER OF HANOI"></a>THE TOWER OF HANOI</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>汉诺塔（也称河内塔）是有法国数学家爱德华·卢卡斯于1883年发明的一道智力题。它源于印度的一个古老传说：大梵天创造世界的时候做了三根钻石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令一组牧师把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。据说牧师们夜以继日地工作，当他们完成任务时，那座塔就将坍塌，世界也将毁灭。</p><p>汉诺塔问题是这样规定的：如下图，一个由8个圆盘组成的塔，这些圆盘从下向上按照大小递减的方式套在一根柱子上，我们的目的是要将这根柱子上的所有圆盘移动到另一根柱子上，每次只能移动一个圆盘，且在移动过程中较大的圆盘不能放置在较小的圆盘上面。</p><img src="C:\Users\罗汝0221\AppData\Roaming\Typora\typora-user-images\image-20200714121332706.png" alt="image-20200714121332706" style="zoom:80%;" /><p>已经证明这个智力题有解，现在问题来了：我们能做到的最好的解法是什么？也就是说，要完成这项任务至少移动多少次才是必须且足够的？</p><p>解决这样的问题的最好方法是对它稍加推广，印度传说中的塔有64个圆盘，汉诺塔问题中的塔有8个圆盘，我们将这个问题推广为有n个圆盘，这样我们简化一下这个问题。如下图，n个圆盘套在A柱上，按照与汉诺塔相同的规则移动到C柱上，至少需要移动多少次。</p><img src="C:\Users\罗汝0221\AppData\Roaming\Typora\typora-user-images\image-20200714122326196.png" alt="image-20200714122326196" style="zoom:80%;" /><h3 id="数学分析"><a href="#数学分析" class="headerlink" title="数学分析"></a>数学分析</h3><p>我们假设T<sub>n</sub> 是根据规则将n个圆盘从一根柱子移动到另一根柱子所需要的最少移动次数。那么T<sub>0</sub>显然是0，T<sub>1</sub> = 1，T<sub>2</sub> = 3。</p><p>现在我们改变一下视角，来考虑大的情形：怎样才能移动一个大的塔呢？将n个圆盘从A柱移动到C柱可以分三步来完成，首先将A柱上面的n-1个圆盘从A柱移动到B柱上，这一步需要移动T<sub>n-1</sub>次。然后将A柱上剩下的那个最大的盘移动到C柱上，这一步需要移动1次。最后将B柱上的n-1个盘移动到C柱上，这一步也需要移动T<sub>n-1</sub>次。所以n(n&gt;0)个圆盘移动2T<sub>n-1</sub>+1次是足够了的，但是我们并没有证明2T<sub>n-1</sub>+1是最少的移动次数，因此：<br>$$<br>T_n \leq 2T_{n-1} + 1, n &gt; 0<br>$$<br>那么还有更好的办法吗？实际上没有，因为我们迟早必须移动最大的那个圆盘。当我们这样做的时候，那n-1个圆盘必须已经在另外某根柱子上，而这一步至少需要移动T<sub>n-1</sub>次，这样我们才能把最大的那个盘移动到第三根柱子上（大盘不能放在小盘上面），移动完最大的盘之后，我们必须把n-1个小的圆盘（此时它们全部处于同一根柱子上）移到最大的盘的上面，这也至少需要移动T<sub>n-1</sub>次，因此：<br>$$<br>T_n \geq 2T_{n-1} + 1,n &gt; 0<br>$$<br>把这两个不等式与n=0时的平凡解结合在一起就得到：<br>$$<br>\begin{cases} T_n = 0,n = 0\ \ T_n = 2T_{n-1} + 1,n &gt; 0 \end{cases}<br>$$<br>得到这样一个递归式之后，我们就可以通过T<sub>0</sub>求出T<sub>1</sub>、由T<sub>1</sub>求出T<sub>2</sub>、由T<sub>2</sub>求出T<sub>3</sub>…最终求出任意的T<sub>n</sub>，这交给计算机程序是很容易计算出T<sub>n</sub>的。但是，如果没有计算机让你去计算T<sub>64</sub>，相信并没人会愿意从T<sub>1</sub>一步一步计算到T<sub>64</sub>。那么有没有一个既漂亮又简介的式子供我们快捷计算T<sub>n</sub>呢，即使n很大？</p><p>我们先在递归式方程的两边加上1：<br>$$<br>\begin{cases} T_n + 1 = 1,n = 0\ \ T_n + 1 = 2T_{n-1} + 2,n &gt; 0 \end{cases}<br>$$<br>现在假设U<sub>n</sub> = T<sub>n</sub> + 1，那么就有：<br>$$<br>\begin{cases} U_n = 1,n = 0\ \ U_n = 2U_{n-1},n &gt; 0 \end{cases}<br>$$<br>显而易见，这个递归方程的解为U<sub>n</sub> = 2<sup>n</sup>（你可以通过数学归纳法证明），从而T<sub>n</sub> = 2<sup>n</sup> - 1。</p><h3 id="代码求解"><a href="#代码求解" class="headerlink" title="代码求解"></a>代码求解</h3><p>下面给出根据上述分析求解结果的Java代码，因计算结果太大，计算过程中均使用BigInteger代替基本数据类型进行运算。</p><p><code>代码</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rul<span class="token punctuation">.</span>mathematics<span class="token punctuation">.</span>hanoi<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>math<span class="token punctuation">.</span>BigInteger<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * THE TOWER OF HANOI * * @author LuoRu */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Hanoi</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"递归求解：T8 = "</span> <span class="token operator">+</span> <span class="token function">getAnswerByRecursive</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span>                <span class="token string">"  T64 = "</span> <span class="token operator">+</span> <span class="token function">getAnswerByRecursive</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"迭代求解：T8 = "</span> <span class="token operator">+</span> <span class="token function">getAnswerByIterate</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span>                <span class="token string">"  T64 = "</span> <span class="token operator">+</span> <span class="token function">getAnswerByIterate</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"公式求解：T8 = "</span> <span class="token operator">+</span> <span class="token function">getAnswerByFormula</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span>                <span class="token string">"  T64 = "</span> <span class="token operator">+</span> <span class="token function">getAnswerByFormula</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 递归方式求解     *     * @param n 汉诺塔圆盘数量     * @return 移动n个盘最少需要移动的次数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> BigInteger <span class="token function">getAnswerByRecursive</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">getAnswerByRecursive</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">multiply</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 迭代方式求解     *     * @param n 汉诺塔圆盘数量     * @return 移动n个盘最少需要移动的次数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> BigInteger <span class="token function">getAnswerByIterate</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        BigInteger answer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            answer <span class="token operator">=</span> answer<span class="token punctuation">.</span><span class="token function">multiply</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> answer<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 一般求解     *     * @param n 汉诺塔圆盘数量     * @return 移动n个盘最少需要移动的次数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> BigInteger <span class="token function">getAnswerByFormula</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        BigInteger answer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> answer<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">subtract</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>结果</code></p><pre><code>递归求解：T8 = 255  T64 = 18446744073709551615迭代求解：T8 = 255  T64 = 18446744073709551615公式求解：T8 = 255  T64 = 18446744073709551615</code></pre><p>可以发现，我们上面得出的T<sub>n</sub> = 2<sup>n</sup> - 1与递归式的结果是一致的。</p><p>假设牧师们1秒钟移动圆盘1次，一天24小时不间断移动，一年算365天，在不犯错的情况下需要大概584942417355年才能将64个盘子移动完。所以牧师们的任务还没有完成，他们现在仍然在移动圆盘。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
